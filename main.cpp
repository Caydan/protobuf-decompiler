
#include <google/protobuf/descriptor.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/dynamic_message.h>
#include <google/protobuf/io/zero_copy_stream_impl.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite.h>
#include <boost/filesystem/operations.hpp>
#include <fstream>
#include <iostream>
#include <string>
#include <unordered_map>

bool ParseFromIstreamWithDescriptorPool(google::protobuf::FileDescriptorProto& proto, std::istream* input)
{
    google::protobuf::io::IstreamInputStream zero_copy_input(input);
    google::protobuf::io::CodedInputStream decoder(&zero_copy_input);
    decoder.SetExtensionRegistry(google::protobuf::DescriptorPool::generated_pool(), google::protobuf::MessageFactory::generated_factory());
    return proto.ParseFromCodedStream(&decoder) && decoder.ConsumedEntireMessage() && input->eof();
}

std::unordered_map<std::string, std::pair<google::protobuf::FileDescriptor const*, bool>> fileDescriptorsByName;
google::protobuf::DynamicMessageFactory* dynamicMessageFactory = new google::protobuf::DynamicMessageFactory(); // LEAKED ON PURPOSE, messages generated by this are double registered (and would be double freed)

int main(int argc, char* argv[])
{
    // initialize Descriptor descriptors
    google::protobuf::DescriptorProto().GetMetadata();

    // first collect files
    boost::filesystem::directory_iterator end;
    std::set<std::string> files;
    for (boost::filesystem::directory_iterator itr(boost::filesystem::current_path()); itr != end; ++itr)
        if (boost::filesystem::is_regular_file(itr->status()))
            if (itr->path().extension().string().find(".protoc") != std::string::npos)
                files.insert(itr->path().string());

    // its time to hack private members
    google::protobuf::DescriptorPool* pool = google::protobuf::DescriptorPool::internal_generated_pool();
    void* mutex_ = *reinterpret_cast<char**>(pool);
    void* fallback_database_ = *(reinterpret_cast<void**>(pool) + 1);
    *reinterpret_cast<void**>(pool) = nullptr; // mutex_
    *(reinterpret_cast<void**>(pool) + 1) = nullptr; // fallback_database_

    std::vector<std::pair<google::protobuf::FileDescriptorProto, bool>> descProtos;
    std::set<std::string> parsed;
    std::list<std::string> parsedSorted;
    // then load everything into descriptor pool
    for (int i = 0; i < files.size(); ++i)
    {
        for (std::string const& fileName : files)
        {
            if (parsed.count(fileName))
                continue;

            std::ifstream in;
            in.open(fileName.c_str(), std::ios::binary | std::ios::in);
            if (!in.good())
                continue;

            google::protobuf::FileDescriptorProto fileDescProto;
            bool parseOk = false;
            try
            {
                parseOk = ParseFromIstreamWithDescriptorPool(fileDescProto, &in);
            }
            catch (...)
            {
                continue;
            }

            if (parseOk)
            {
                if (google::protobuf::FileDescriptor const* fileDesc = pool->BuildFile(fileDescProto))
                {
                    if (fileDesc->name() != "google/protobuf/descriptor.proto" && fileDescriptorsByName.count(fileDesc->name()) == 0)
                    {
                        fileDescriptorsByName[fileDesc->name()] = std::make_pair(fileDesc, false);
                        google::protobuf::MessageFactory::InternalRegisterGeneratedFile(strdup(fileDesc->name().c_str()), [](std::string const& name)
                        {
                            std::pair<google::protobuf::FileDescriptor const*, bool>& p = fileDescriptorsByName[name];
                            if (p.second)
                                return;

                            p.second = true;
                            google::protobuf::FileDescriptor const* desc = p.first;
                            for (int i = 0; i < desc->message_type_count(); ++i)
                                google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(desc->message_type(i), dynamicMessageFactory->GetPrototype(desc->message_type(i)));
                        });
                    }

                    for (int i = 0; i < fileDesc->extension_count(); ++i)
                    {
                        google::protobuf::FieldDescriptor const* extension = fileDesc->extension(i);
                        switch (extension->type())
                        {
                            case google::protobuf::internal::WireFormatLite::TYPE_ENUM:
                                google::protobuf::internal::ExtensionSet::RegisterEnumExtension(
                                    google::protobuf::MessageFactory::generated_factory()->GetPrototype(extension->containing_type()),
                                    extension->number(),
                                    extension->type(),
                                    extension->is_repeated(),
                                    extension->is_packed(),
                                    [](int){ return true; });
                                break;
                            case google::protobuf::internal::WireFormatLite::TYPE_MESSAGE:
                            case google::protobuf::internal::WireFormatLite::TYPE_GROUP:
                                google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
                                    google::protobuf::MessageFactory::generated_factory()->GetPrototype(extension->containing_type()),
                                    extension->number(),
                                    extension->type(),
                                    extension->is_repeated(),
                                    extension->is_packed(),
                                    google::protobuf::MessageFactory::generated_factory()->GetPrototype(extension->message_type()));
                                break;
                            default:
                                google::protobuf::internal::ExtensionSet::RegisterExtension(
                                    google::protobuf::MessageFactory::generated_factory()->GetPrototype(extension->containing_type()),
                                    extension->number(),
                                    extension->type(),
                                    extension->is_repeated(),
                                    extension->is_packed());
                                break;
                        }
                    }

                    parsed.insert(fileName);
                    if (fileDesc->name() != "google/protobuf/descriptor.proto")
                        parsedSorted.push_back(fileName);
                    else
                        parsedSorted.push_front(fileName);
                }
            }
        }
    }

    // and finally rebuild all protos in a new pool with fully resolved dependencies and extensions
    google::protobuf::DescriptorPool* pool2 = new google::protobuf::DescriptorPool();
    for (std::string const& fileName : parsedSorted)
    {
        std::ifstream in;
        in.open(fileName.c_str(), std::ios::binary | std::ios::in);
        if (!in.good())
            continue;

        google::protobuf::FileDescriptorProto fileDescProto;
        if (ParseFromIstreamWithDescriptorPool(fileDescProto, &in))
        {
            fileDescProto.mutable_options()->set_optimize_for(google::protobuf::FileOptions_OptimizeMode_SPEED);
            if (google::protobuf::FileDescriptor const* fileDesc = pool2->BuildFile(fileDescProto))
            {
                boost::filesystem::path parentPath = boost::filesystem::path(fileDesc->name()).parent_path();
                if (!parentPath.empty())
                    boost::filesystem::create_directories(parentPath);
                std::ofstream f(fileDesc->name());
                f << fileDesc->DebugString() << std::endl;
                f.close();
            }
        }
    }

    // unhack to free memory
    *reinterpret_cast<void**>(pool) = mutex_;
    *(reinterpret_cast<void**>(pool) + 1) = fallback_database_;

    delete pool2;

    google::protobuf::ShutdownProtobufLibrary();

    return 0;
}
